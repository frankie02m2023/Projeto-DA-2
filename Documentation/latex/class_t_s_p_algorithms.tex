\doxysection{TSPAlgorithms Class Reference}
\hypertarget{class_t_s_p_algorithms}{}\label{class_t_s_p_algorithms}\index{TSPAlgorithms@{TSPAlgorithms}}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_t_s_p_algorithms_acefaa87ab90b1eba9ed417d60e934213}{TSPAlgorithms}} (\mbox{\hyperlink{class_edge}{const}} \mbox{\hyperlink{class_edge}{string}} \&graph\+Name)
\begin{DoxyCompactList}\small\item\em Constructor for \doxylink{class_t_s_p_algorithms}{TSPAlgorithms}, sets the graph name. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_edge}{string}} \mbox{\hyperlink{class_t_s_p_algorithms_a8dea888ab956edd46160ccf54ee6c95b}{get\+Graph\+Name}} () \mbox{\hyperlink{class_edge}{const}}
\begin{DoxyCompactList}\small\item\em Gets the name of the graph. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_graph}{Graph}} \mbox{\hyperlink{class_t_s_p_algorithms_ae49ea8cdd0f56dce7493b0a470012e64}{get\+Graph}} () \mbox{\hyperlink{class_edge}{const}}
\begin{DoxyCompactList}\small\item\em Retrieves the graph. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_edge}{bool}} \mbox{\hyperlink{class_t_s_p_algorithms_afba4fbbec08698e6172dbcd19a62a215}{is\+Graph\+Fully\+Connected}} () \mbox{\hyperlink{class_edge}{const}}
\begin{DoxyCompactList}\small\item\em Checks if the graph is fully connected. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_edge}{void}} \mbox{\hyperlink{class_t_s_p_algorithms_ae6a82fda7b3eac284ede9c61c65766e0}{set\+Graph\+Name}} (\mbox{\hyperlink{class_edge}{const}} \mbox{\hyperlink{class_edge}{string}} \&graph\+Name)
\begin{DoxyCompactList}\small\item\em Sets the name of the graph. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_edge}{void}} \mbox{\hyperlink{class_t_s_p_algorithms_a9c4c801c892093c4aaf15a22bf3c685a}{load\+Graph}} ()
\begin{DoxyCompactList}\small\item\em Loads the graph by first loading the vertices and then the edges. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_edge}{double}} \mbox{\hyperlink{class_t_s_p_algorithms_a44c33ce200e7613bb367ccd02127f597}{get\+Min\+Dist\+With\+Back\+Tracking}} (\mbox{\hyperlink{class_edge}{stack}}$<$ \mbox{\hyperlink{class_node}{Node}} $>$ \&\mbox{\hyperlink{class_edge}{min\+Dist\+Path}})
\begin{DoxyCompactList}\small\item\em Finds the minimum distance using the backtracking algorithm. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_edge}{double}} \mbox{\hyperlink{class_t_s_p_algorithms_a51c894c5952d85287e140e3894ceb88e}{get\+Min\+Dist\+With\+Triangular\+Inequality}} (\mbox{\hyperlink{class_edge}{vector}}$<$ \mbox{\hyperlink{class_node}{Node}} $>$ \&\mbox{\hyperlink{class_edge}{min\+Dist\+Path}})
\begin{DoxyCompactList}\small\item\em Finds the minimum distance using the triangular inequality and MST. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_edge}{double}} \mbox{\hyperlink{class_t_s_p_algorithms_a8878e9de5671b94c682e624467c892c2}{get\+Min\+Dist\+With\+Nearest\+Neighbour}} (\mbox{\hyperlink{class_edge}{vector}}$<$ \mbox{\hyperlink{class_node}{Node}} $>$ \&\mbox{\hyperlink{class_edge}{min\+Dist\+Path}})
\begin{DoxyCompactList}\small\item\em Finds the minimum distance using the nearest neighbour and 2-\/opt algorithms. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_edge}{double}} \mbox{\hyperlink{class_t_s_p_algorithms_acd73da6e0a85f3cfa3dcc08e6b6fb89d}{get\+Min\+Dist\+With\+Christofides\+Algorithm}} (\mbox{\hyperlink{class_edge}{vector}}$<$ \mbox{\hyperlink{class_node}{Node}} $>$ \&\mbox{\hyperlink{class_edge}{min\+Dist\+Path}})
\begin{DoxyCompactList}\small\item\em Finds the minimum distance using the Christofides algorithm. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_edge}{void}} \mbox{\hyperlink{class_t_s_p_algorithms_a3957e450d4599f8ee3ff28105b6aed02}{load\+Graph\+Vertexes}} ()
\begin{DoxyCompactList}\small\item\em Loads the vertices of the graph from different data sources based on the graph name. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_edge}{void}} \mbox{\hyperlink{class_t_s_p_algorithms_af964e3fa6df8ef1477fa472b2daf608d}{load\+Graph\+Edges}} (\mbox{\hyperlink{class_edge}{unsigned}} \mbox{\hyperlink{class_edge}{int}} \&\mbox{\hyperlink{class_edge}{number\+Of\+Graph\+Edges}})
\begin{DoxyCompactList}\small\item\em Loads the edges of the graph and calculates the number of edges. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_edge}{void}} \mbox{\hyperlink{class_t_s_p_algorithms_aa4f1c8253c475ccb98f69d4a342c52c6}{set\+All\+Vertexes\+As\+Unvisited}} ()
\begin{DoxyCompactList}\small\item\em Sets all vertices in the graph as unvisited. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_edge}{void}} \mbox{\hyperlink{class_t_s_p_algorithms_ad109e1d5a64bea6518987510325e5caa}{set\+All\+Vertex\+Paths\+Null}} ()
\begin{DoxyCompactList}\small\item\em Sets the path of all vertices to null. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_edge}{void}} \mbox{\hyperlink{class_t_s_p_algorithms_a98ff6471bd1b28828eafa4600bbb4258}{DFSBacktracking}} (\mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{class_edge}{vertex}}, \mbox{\hyperlink{class_edge}{double}} \&\mbox{\hyperlink{class_edge}{distance}}, \mbox{\hyperlink{class_edge}{double}} \&\mbox{\hyperlink{class_edge}{min\+Distance}}, \mbox{\hyperlink{class_edge}{stack}}$<$ \mbox{\hyperlink{class_node}{Node}} $>$ \&path, \mbox{\hyperlink{class_edge}{stack}}$<$ \mbox{\hyperlink{class_node}{Node}} $>$ \&\mbox{\hyperlink{class_edge}{min\+Dist\+Path}})
\begin{DoxyCompactList}\small\item\em Recursive function to perform DFS for the backtracking algorithm. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{class_t_s_p_algorithms_a10ef105bf266a10fde97919bf2796b39}{find\+Min\+Dist\+Vertex}} (\mbox{\hyperlink{class_edge}{vector}}$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \mbox{\hyperlink{class_edge}{vertexes}})
\begin{DoxyCompactList}\small\item\em Finds the vertex with the minimum distance that has not been visited. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_edge}{void}} \mbox{\hyperlink{class_t_s_p_algorithms_a1828911a5c896eed0f47ffc54a5f907d}{prim\+Algorithm}} (\mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{class_edge}{root}})
\begin{DoxyCompactList}\small\item\em Performs Prim\textquotesingle{}s algorithm to create an MST starting from the root vertex. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_edge}{void}} \mbox{\hyperlink{class_t_s_p_algorithms_a692f2d66d8b3f323a4047c610a4a0ebf}{MSTPre\+Order\+Visit\+DFS}} (\mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{class_edge}{root}}, \mbox{\hyperlink{class_edge}{vector}}$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \&\mbox{\hyperlink{class_edge}{min\+Distance\+Path}})
\begin{DoxyCompactList}\small\item\em Performs a pre-\/order DFS visit of the MST. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_edge}{double}} \mbox{\hyperlink{class_t_s_p_algorithms_accea94f7f88211c4d95b76d545471917}{get\+Nearest\+Neighbour\+Dist}} (\mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{class_edge}{vertex}}, \mbox{\hyperlink{class_node}{Node}} \&\mbox{\hyperlink{class_edge}{selected\+Node}}, \mbox{\hyperlink{class_edge}{bool}} \&\mbox{\hyperlink{class_edge}{found\+New\+Edges}})
\begin{DoxyCompactList}\small\item\em Gets the nearest neighbour distance for the current vertex. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_edge}{double}} \mbox{\hyperlink{class_t_s_p_algorithms_a032b48e8ca6d2cf94db9b8ccbd7add8c}{find\+Or\+Calculate\+Distance\+Between\+Vertexes}} (\mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{class_edge}{v1}}, \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{class_edge}{v2}})
\begin{DoxyCompactList}\small\item\em Finds or calculates the distance between two vertices. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_edge}{void}} \mbox{\hyperlink{class_t_s_p_algorithms_ae42132ecda567c2332390f7f9403cd95}{prim\+Algorithm\+Christofides}} (\mbox{\hyperlink{class_graph}{Graph}} \&\mbox{\hyperlink{class_edge}{mst\+Graph}}, \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{class_edge}{vertex}})
\begin{DoxyCompactList}\small\item\em Performs Prim\textquotesingle{}s algorithm for Christofides to create an MST. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_edge}{vector}}$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \mbox{\hyperlink{class_t_s_p_algorithms_af9e29de393ee602e6e419460ba429bfe}{get\+Odd\+Degrees}} (\mbox{\hyperlink{class_graph}{Graph}} \mbox{\hyperlink{class_edge}{mst\+Graph}})
\begin{DoxyCompactList}\small\item\em Gets the vertices with odd degrees in the MST. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_edge}{bool}} \mbox{\hyperlink{class_t_s_p_algorithms_aa639e086de224586f4a231aa81a0d52a}{edge\+Between\+Vertexes}} (\mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{class_edge}{v1}}, \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{class_edge}{v2}})
\begin{DoxyCompactList}\small\item\em Checks if there is an edge between two vertices. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_edge}{void}} \mbox{\hyperlink{class_t_s_p_algorithms_ab77c56d39f2ff325ffdddd689f57b296}{find\+Perfect\+Matching}} (\mbox{\hyperlink{class_graph}{Graph}} \&\mbox{\hyperlink{class_edge}{mst\+Graph}}, \mbox{\hyperlink{class_edge}{vector}}$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \mbox{\hyperlink{class_edge}{vertex}})
\begin{DoxyCompactList}\small\item\em Finds a perfect matching for the vertices with odd degrees. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_edge}{bool}} \mbox{\hyperlink{class_t_s_p_algorithms_a900ed322abb8a7d355c465bb6af23c3f}{edge\+Is\+Bridge}} (\mbox{\hyperlink{class_edge}{Edge}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{class_edge}{edge}}, \mbox{\hyperlink{class_graph}{Graph}} \&\mbox{\hyperlink{class_edge}{mst\+Graph}})
\begin{DoxyCompactList}\small\item\em Checks if an edge is a bridge. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_edge}{void}} \mbox{\hyperlink{class_t_s_p_algorithms_a5511957d1dc14115e50148f5c3a8a433}{dfs\+Edge\+Is\+Bridge}} (\mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{class_edge}{vertex}}, \mbox{\hyperlink{class_edge}{unsigned}} \mbox{\hyperlink{class_edge}{int}} \&\mbox{\hyperlink{class_edge}{number\+Of\+Reachable\+Edges}})
\begin{DoxyCompactList}\small\item\em Performs a DFS to check if an edge is a bridge. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_edge}{void}} \mbox{\hyperlink{class_t_s_p_algorithms_a4c019da286d31a02dc4f4b4f304ccfe9}{euler\+Path\+DFS}} (\mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{class_edge}{vertex}}, \mbox{\hyperlink{class_edge}{vector}}$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \&\mbox{\hyperlink{class_edge}{euler\+Path}}, \mbox{\hyperlink{class_graph}{Graph}} \&\mbox{\hyperlink{class_edge}{mst\+Graph}})
\begin{DoxyCompactList}\small\item\em Performs a Depth-\/\+First Search (DFS) to find the Eulerian path in the MST. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_edge}{vector}}$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \mbox{\hyperlink{class_t_s_p_algorithms_a7aa53893af4da37dde728c2b002208ee}{find\+Euler\+Path}} (\mbox{\hyperlink{class_graph}{Graph}} \&\mbox{\hyperlink{class_edge}{mst\+Graph}})
\begin{DoxyCompactList}\small\item\em Finds the Eulerian path in the MST. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_edge}{vector}}$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \mbox{\hyperlink{class_t_s_p_algorithms_ad85ae04ce7399ff2d561a968519ab1f5}{build\+Hamiltonian\+Path}} (\mbox{\hyperlink{class_edge}{vector}}$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \mbox{\hyperlink{class_edge}{euler\+Path}})
\begin{DoxyCompactList}\small\item\em Builds the Hamiltonian path from the given Eulerian path. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{class_t_s_p_algorithms_a9f327fd64cac294ded1c93dde25bf24c}\label{class_t_s_p_algorithms_a9f327fd64cac294ded1c93dde25bf24c} 
\mbox{\hyperlink{class_graph}{Graph}} {\bfseries graph}
\item 
\Hypertarget{class_t_s_p_algorithms_aa342653c4b0e979e5e761cfd2aab5696}\label{class_t_s_p_algorithms_aa342653c4b0e979e5e761cfd2aab5696} 
\mbox{\hyperlink{class_edge}{string}} {\bfseries graph\+Name}
\item 
\Hypertarget{class_t_s_p_algorithms_aa1670e9f5e1fa93c133a8e26163ca495}\label{class_t_s_p_algorithms_aa1670e9f5e1fa93c133a8e26163ca495} 
\mbox{\hyperlink{class_edge}{bool}} {\bfseries graph\+Is\+Fully\+Connected}
\end{DoxyCompactItemize}


\doxysubsection{Constructor \& Destructor Documentation}
\Hypertarget{class_t_s_p_algorithms_acefaa87ab90b1eba9ed417d60e934213}\label{class_t_s_p_algorithms_acefaa87ab90b1eba9ed417d60e934213} 
\index{TSPAlgorithms@{TSPAlgorithms}!TSPAlgorithms@{TSPAlgorithms}}
\index{TSPAlgorithms@{TSPAlgorithms}!TSPAlgorithms@{TSPAlgorithms}}
\doxysubsubsection{\texorpdfstring{TSPAlgorithms()}{TSPAlgorithms()}}
{\footnotesize\ttfamily TSPAlgorithms\+::\+TSPAlgorithms (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_edge}{const}} \mbox{\hyperlink{class_edge}{string}} \&}]{graph\+Name }\end{DoxyParamCaption})}



Constructor for \doxylink{class_t_s_p_algorithms}{TSPAlgorithms}, sets the graph name. 


\begin{DoxyParams}{Parameters}
{\em graph\+Name} & The name of the graph.\\
\hline
\end{DoxyParams}
Complexity\+: O(1) 

\doxysubsection{Member Function Documentation}
\Hypertarget{class_t_s_p_algorithms_ad85ae04ce7399ff2d561a968519ab1f5}\label{class_t_s_p_algorithms_ad85ae04ce7399ff2d561a968519ab1f5} 
\index{TSPAlgorithms@{TSPAlgorithms}!buildHamiltonianPath@{buildHamiltonianPath}}
\index{buildHamiltonianPath@{buildHamiltonianPath}!TSPAlgorithms@{TSPAlgorithms}}
\doxysubsubsection{\texorpdfstring{buildHamiltonianPath()}{buildHamiltonianPath()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_edge}{vector}}$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ TSPAlgorithms\+::build\+Hamiltonian\+Path (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_edge}{vector}}$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$}]{euler\+Path }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Builds the Hamiltonian path from the given Eulerian path. 


\begin{DoxyParams}{Parameters}
{\em euler\+Path} & The Eulerian path. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The vector of vertices representing the Hamiltonian path.
\end{DoxyReturn}
Complexity\+: O(\+V) where V is the number of vertices. \Hypertarget{class_t_s_p_algorithms_a98ff6471bd1b28828eafa4600bbb4258}\label{class_t_s_p_algorithms_a98ff6471bd1b28828eafa4600bbb4258} 
\index{TSPAlgorithms@{TSPAlgorithms}!DFSBacktracking@{DFSBacktracking}}
\index{DFSBacktracking@{DFSBacktracking}!TSPAlgorithms@{TSPAlgorithms}}
\doxysubsubsection{\texorpdfstring{DFSBacktracking()}{DFSBacktracking()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_edge}{void}} TSPAlgorithms\+::\+DFSBacktracking (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}}]{vertex,  }\item[{\mbox{\hyperlink{class_edge}{double}} \&}]{distance,  }\item[{\mbox{\hyperlink{class_edge}{double}} \&}]{min\+Distance,  }\item[{\mbox{\hyperlink{class_edge}{stack}}$<$ \mbox{\hyperlink{class_node}{Node}} $>$ \&}]{path,  }\item[{\mbox{\hyperlink{class_edge}{stack}}$<$ \mbox{\hyperlink{class_node}{Node}} $>$ \&}]{min\+Dist\+Path }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Recursive function to perform DFS for the backtracking algorithm. 


\begin{DoxyParams}{Parameters}
{\em vertex} & The current vertex. \\
\hline
{\em distance} & The current distance. \\
\hline
{\em min\+Distance} & The minimum distance found. \\
\hline
{\em path} & The current path. \\
\hline
{\em min\+Distance\+Path} & The path with the minimum distance.\\
\hline
\end{DoxyParams}
Complexity\+: O((V+E)!) where V is the number of vertices and E is the number of edges. \Hypertarget{class_t_s_p_algorithms_a5511957d1dc14115e50148f5c3a8a433}\label{class_t_s_p_algorithms_a5511957d1dc14115e50148f5c3a8a433} 
\index{TSPAlgorithms@{TSPAlgorithms}!dfsEdgeIsBridge@{dfsEdgeIsBridge}}
\index{dfsEdgeIsBridge@{dfsEdgeIsBridge}!TSPAlgorithms@{TSPAlgorithms}}
\doxysubsubsection{\texorpdfstring{dfsEdgeIsBridge()}{dfsEdgeIsBridge()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_edge}{void}} TSPAlgorithms\+::dfs\+Edge\+Is\+Bridge (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}}]{vertex,  }\item[{\mbox{\hyperlink{class_edge}{unsigned}} \mbox{\hyperlink{class_edge}{int}} \&}]{number\+Of\+Reachable\+Edges }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Performs a DFS to check if an edge is a bridge. 


\begin{DoxyParams}{Parameters}
{\em vertex} & The current vertex. \\
\hline
{\em number\+Of\+Reachable\+Edges} & The number of reachable edges.\\
\hline
\end{DoxyParams}
Complexity\+: O(V + E) where V is the number of vertices and E is the number of edges. \Hypertarget{class_t_s_p_algorithms_aa639e086de224586f4a231aa81a0d52a}\label{class_t_s_p_algorithms_aa639e086de224586f4a231aa81a0d52a} 
\index{TSPAlgorithms@{TSPAlgorithms}!edgeBetweenVertexes@{edgeBetweenVertexes}}
\index{edgeBetweenVertexes@{edgeBetweenVertexes}!TSPAlgorithms@{TSPAlgorithms}}
\doxysubsubsection{\texorpdfstring{edgeBetweenVertexes()}{edgeBetweenVertexes()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_edge}{bool}} TSPAlgorithms\+::edge\+Between\+Vertexes (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}}]{v1,  }\item[{\mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}}]{v2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Checks if there is an edge between two vertices. 


\begin{DoxyParams}{Parameters}
{\em v1} & The first vertex. \\
\hline
{\em v2} & The second vertex. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if there is an edge, false otherwise.
\end{DoxyReturn}
Complexity\+: O(\+E) where E is the number of edges. \Hypertarget{class_t_s_p_algorithms_a900ed322abb8a7d355c465bb6af23c3f}\label{class_t_s_p_algorithms_a900ed322abb8a7d355c465bb6af23c3f} 
\index{TSPAlgorithms@{TSPAlgorithms}!edgeIsBridge@{edgeIsBridge}}
\index{edgeIsBridge@{edgeIsBridge}!TSPAlgorithms@{TSPAlgorithms}}
\doxysubsubsection{\texorpdfstring{edgeIsBridge()}{edgeIsBridge()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_edge}{bool}} TSPAlgorithms\+::edge\+Is\+Bridge (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_edge}{Edge}} \texorpdfstring{$\ast$}{*}}]{edge,  }\item[{\mbox{\hyperlink{class_graph}{Graph}} \&}]{mst\+Graph }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Checks if an edge is a bridge. 


\begin{DoxyParams}{Parameters}
{\em edge} & The edge. \\
\hline
{\em mst\+Graph} & The MST graph. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the edge is a bridge, false otherwise.
\end{DoxyReturn}
Complexity\+: O(V + E) where V is the number of vertices and E is the number of edges. \Hypertarget{class_t_s_p_algorithms_a4c019da286d31a02dc4f4b4f304ccfe9}\label{class_t_s_p_algorithms_a4c019da286d31a02dc4f4b4f304ccfe9} 
\index{TSPAlgorithms@{TSPAlgorithms}!eulerPathDFS@{eulerPathDFS}}
\index{eulerPathDFS@{eulerPathDFS}!TSPAlgorithms@{TSPAlgorithms}}
\doxysubsubsection{\texorpdfstring{eulerPathDFS()}{eulerPathDFS()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_edge}{void}} TSPAlgorithms\+::euler\+Path\+DFS (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}}]{vertex,  }\item[{\mbox{\hyperlink{class_edge}{vector}}$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \&}]{euler\+Path,  }\item[{\mbox{\hyperlink{class_graph}{Graph}} \&}]{mst\+Graph }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Performs a Depth-\/\+First Search (DFS) to find the Eulerian path in the MST. 


\begin{DoxyParams}{Parameters}
{\em vertex} & The current vertex being visited. \\
\hline
{\em euler\+Path} & The vector to store the Eulerian path. \\
\hline
{\em mst\+Graph} & The MST graph.\\
\hline
\end{DoxyParams}
Complexity\+: O((V + E)\texorpdfstring{$^\wedge$}{\string^}2) where V is the number of vertices and E is the number of edges. \Hypertarget{class_t_s_p_algorithms_a7aa53893af4da37dde728c2b002208ee}\label{class_t_s_p_algorithms_a7aa53893af4da37dde728c2b002208ee} 
\index{TSPAlgorithms@{TSPAlgorithms}!findEulerPath@{findEulerPath}}
\index{findEulerPath@{findEulerPath}!TSPAlgorithms@{TSPAlgorithms}}
\doxysubsubsection{\texorpdfstring{findEulerPath()}{findEulerPath()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_edge}{vector}}$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ TSPAlgorithms\+::find\+Euler\+Path (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_graph}{Graph}} \&}]{mst\+Graph }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Finds the Eulerian path in the MST. 


\begin{DoxyParams}{Parameters}
{\em mst\+Graph} & The MST graph. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The vector of vertices representing the Eulerian path.
\end{DoxyReturn}
Complexity\+: O((V + E)\texorpdfstring{$^\wedge$}{\string^}2) where V is the number of vertices and E is the number of edges. \Hypertarget{class_t_s_p_algorithms_a10ef105bf266a10fde97919bf2796b39}\label{class_t_s_p_algorithms_a10ef105bf266a10fde97919bf2796b39} 
\index{TSPAlgorithms@{TSPAlgorithms}!findMinDistVertex@{findMinDistVertex}}
\index{findMinDistVertex@{findMinDistVertex}!TSPAlgorithms@{TSPAlgorithms}}
\doxysubsubsection{\texorpdfstring{findMinDistVertex()}{findMinDistVertex()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} TSPAlgorithms\+::find\+Min\+Dist\+Vertex (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_edge}{vector}}$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$}]{vertexes }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Finds the vertex with the minimum distance that has not been visited. 


\begin{DoxyParams}{Parameters}
{\em vertexes} & The list of vertices. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The vertex with the minimum distance.
\end{DoxyReturn}
Complexity\+: O(\+V) where V is the number of vertices. \Hypertarget{class_t_s_p_algorithms_a032b48e8ca6d2cf94db9b8ccbd7add8c}\label{class_t_s_p_algorithms_a032b48e8ca6d2cf94db9b8ccbd7add8c} 
\index{TSPAlgorithms@{TSPAlgorithms}!findOrCalculateDistanceBetweenVertexes@{findOrCalculateDistanceBetweenVertexes}}
\index{findOrCalculateDistanceBetweenVertexes@{findOrCalculateDistanceBetweenVertexes}!TSPAlgorithms@{TSPAlgorithms}}
\doxysubsubsection{\texorpdfstring{findOrCalculateDistanceBetweenVertexes()}{findOrCalculateDistanceBetweenVertexes()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_edge}{double}} TSPAlgorithms\+::find\+Or\+Calculate\+Distance\+Between\+Vertexes (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}}]{v1,  }\item[{\mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}}]{v2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Finds or calculates the distance between two vertices. 


\begin{DoxyParams}{Parameters}
{\em v1} & The first vertex. \\
\hline
{\em v2} & The second vertex. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The distance between the two vertices.
\end{DoxyReturn}
Complexity\+: O(\+E) where E is the number of edges. \Hypertarget{class_t_s_p_algorithms_ab77c56d39f2ff325ffdddd689f57b296}\label{class_t_s_p_algorithms_ab77c56d39f2ff325ffdddd689f57b296} 
\index{TSPAlgorithms@{TSPAlgorithms}!findPerfectMatching@{findPerfectMatching}}
\index{findPerfectMatching@{findPerfectMatching}!TSPAlgorithms@{TSPAlgorithms}}
\doxysubsubsection{\texorpdfstring{findPerfectMatching()}{findPerfectMatching()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_edge}{void}} TSPAlgorithms\+::find\+Perfect\+Matching (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_graph}{Graph}} \&}]{mst\+Graph,  }\item[{\mbox{\hyperlink{class_edge}{vector}}$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$}]{vertex }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Finds a perfect matching for the vertices with odd degrees. 


\begin{DoxyParams}{Parameters}
{\em mst\+Graph} & The MST graph. \\
\hline
{\em odd\+Degree\+Vertexes} & The vertices with odd degrees.\\
\hline
\end{DoxyParams}
Complexity\+: O(\+V\texorpdfstring{$^\wedge$}{\string^}2) where V is the number of vertices. \Hypertarget{class_t_s_p_algorithms_ae49ea8cdd0f56dce7493b0a470012e64}\label{class_t_s_p_algorithms_ae49ea8cdd0f56dce7493b0a470012e64} 
\index{TSPAlgorithms@{TSPAlgorithms}!getGraph@{getGraph}}
\index{getGraph@{getGraph}!TSPAlgorithms@{TSPAlgorithms}}
\doxysubsubsection{\texorpdfstring{getGraph()}{getGraph()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_graph}{Graph}} TSPAlgorithms\+::get\+Graph (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Retrieves the graph. 

\begin{DoxyReturn}{Returns}
The graph of nodes.
\end{DoxyReturn}
Complexity\+: O(1) \Hypertarget{class_t_s_p_algorithms_a8dea888ab956edd46160ccf54ee6c95b}\label{class_t_s_p_algorithms_a8dea888ab956edd46160ccf54ee6c95b} 
\index{TSPAlgorithms@{TSPAlgorithms}!getGraphName@{getGraphName}}
\index{getGraphName@{getGraphName}!TSPAlgorithms@{TSPAlgorithms}}
\doxysubsubsection{\texorpdfstring{getGraphName()}{getGraphName()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_edge}{string}} TSPAlgorithms\+::get\+Graph\+Name (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Gets the name of the graph. 

\begin{DoxyReturn}{Returns}
The name of the graph.
\end{DoxyReturn}
Complexity\+: O(1) \Hypertarget{class_t_s_p_algorithms_a44c33ce200e7613bb367ccd02127f597}\label{class_t_s_p_algorithms_a44c33ce200e7613bb367ccd02127f597} 
\index{TSPAlgorithms@{TSPAlgorithms}!getMinDistWithBackTracking@{getMinDistWithBackTracking}}
\index{getMinDistWithBackTracking@{getMinDistWithBackTracking}!TSPAlgorithms@{TSPAlgorithms}}
\doxysubsubsection{\texorpdfstring{getMinDistWithBackTracking()}{getMinDistWithBackTracking()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_edge}{double}} TSPAlgorithms\+::get\+Min\+Dist\+With\+Back\+Tracking (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_edge}{stack}}$<$ \mbox{\hyperlink{class_node}{Node}} $>$ \&}]{min\+Dist\+Path }\end{DoxyParamCaption})}



Finds the minimum distance using the backtracking algorithm. 


\begin{DoxyParams}{Parameters}
{\em min\+Distance\+Path} & The path with the minimum distance. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The minimum distance.
\end{DoxyReturn}
Complexity\+: O((V+E)!) where V is the number of vertices and E is the number of edges. \Hypertarget{class_t_s_p_algorithms_acd73da6e0a85f3cfa3dcc08e6b6fb89d}\label{class_t_s_p_algorithms_acd73da6e0a85f3cfa3dcc08e6b6fb89d} 
\index{TSPAlgorithms@{TSPAlgorithms}!getMinDistWithChristofidesAlgorithm@{getMinDistWithChristofidesAlgorithm}}
\index{getMinDistWithChristofidesAlgorithm@{getMinDistWithChristofidesAlgorithm}!TSPAlgorithms@{TSPAlgorithms}}
\doxysubsubsection{\texorpdfstring{getMinDistWithChristofidesAlgorithm()}{getMinDistWithChristofidesAlgorithm()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_edge}{double}} TSPAlgorithms\+::get\+Min\+Dist\+With\+Christofides\+Algorithm (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_edge}{vector}}$<$ \mbox{\hyperlink{class_node}{Node}} $>$ \&}]{min\+Dist\+Path }\end{DoxyParamCaption})}



Finds the minimum distance using the Christofides algorithm. 


\begin{DoxyParams}{Parameters}
{\em min\+Dist\+Path} & The path with the minimum distance. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The minimum distance.
\end{DoxyReturn}
Complexity\+: O(\+V\texorpdfstring{$^\wedge$}{\string^}3) where V is the number of vertices. \Hypertarget{class_t_s_p_algorithms_a8878e9de5671b94c682e624467c892c2}\label{class_t_s_p_algorithms_a8878e9de5671b94c682e624467c892c2} 
\index{TSPAlgorithms@{TSPAlgorithms}!getMinDistWithNearestNeighbour@{getMinDistWithNearestNeighbour}}
\index{getMinDistWithNearestNeighbour@{getMinDistWithNearestNeighbour}!TSPAlgorithms@{TSPAlgorithms}}
\doxysubsubsection{\texorpdfstring{getMinDistWithNearestNeighbour()}{getMinDistWithNearestNeighbour()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_edge}{double}} TSPAlgorithms\+::get\+Min\+Dist\+With\+Nearest\+Neighbour (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_edge}{vector}}$<$ \mbox{\hyperlink{class_node}{Node}} $>$ \&}]{min\+Dist\+Path }\end{DoxyParamCaption})}



Finds the minimum distance using the nearest neighbour and 2-\/opt algorithms. 


\begin{DoxyParams}{Parameters}
{\em min\+Dist\+Path} & The path with the minimum distance. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The minimum distance.
\end{DoxyReturn}
Complexity\+: O(\+V\texorpdfstring{$^\wedge$}{\string^}2) where V is the number of vertices. \Hypertarget{class_t_s_p_algorithms_a51c894c5952d85287e140e3894ceb88e}\label{class_t_s_p_algorithms_a51c894c5952d85287e140e3894ceb88e} 
\index{TSPAlgorithms@{TSPAlgorithms}!getMinDistWithTriangularInequality@{getMinDistWithTriangularInequality}}
\index{getMinDistWithTriangularInequality@{getMinDistWithTriangularInequality}!TSPAlgorithms@{TSPAlgorithms}}
\doxysubsubsection{\texorpdfstring{getMinDistWithTriangularInequality()}{getMinDistWithTriangularInequality()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_edge}{double}} TSPAlgorithms\+::get\+Min\+Dist\+With\+Triangular\+Inequality (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_edge}{vector}}$<$ \mbox{\hyperlink{class_node}{Node}} $>$ \&}]{min\+Dist\+Path }\end{DoxyParamCaption})}



Finds the minimum distance using the triangular inequality and MST. 


\begin{DoxyParams}{Parameters}
{\em min\+Dist\+Path} & The path with the minimum distance. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The minimum distance.
\end{DoxyReturn}
Complexity\+: O(\+V\texorpdfstring{$^\wedge$}{\string^}2) where V is the number of vertices. \Hypertarget{class_t_s_p_algorithms_accea94f7f88211c4d95b76d545471917}\label{class_t_s_p_algorithms_accea94f7f88211c4d95b76d545471917} 
\index{TSPAlgorithms@{TSPAlgorithms}!getNearestNeighbourDist@{getNearestNeighbourDist}}
\index{getNearestNeighbourDist@{getNearestNeighbourDist}!TSPAlgorithms@{TSPAlgorithms}}
\doxysubsubsection{\texorpdfstring{getNearestNeighbourDist()}{getNearestNeighbourDist()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_edge}{double}} TSPAlgorithms\+::get\+Nearest\+Neighbour\+Dist (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}}]{vertex,  }\item[{\mbox{\hyperlink{class_node}{Node}} \&}]{selected\+Node,  }\item[{\mbox{\hyperlink{class_edge}{bool}} \&}]{found\+New\+Edges }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Gets the nearest neighbour distance for the current vertex. 


\begin{DoxyParams}{Parameters}
{\em vertex} & The current vertex. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The nearest neighbour distance.
\end{DoxyReturn}
Complexity\+: O(\+V) where V is the number of vertices. \Hypertarget{class_t_s_p_algorithms_af9e29de393ee602e6e419460ba429bfe}\label{class_t_s_p_algorithms_af9e29de393ee602e6e419460ba429bfe} 
\index{TSPAlgorithms@{TSPAlgorithms}!getOddDegrees@{getOddDegrees}}
\index{getOddDegrees@{getOddDegrees}!TSPAlgorithms@{TSPAlgorithms}}
\doxysubsubsection{\texorpdfstring{getOddDegrees()}{getOddDegrees()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_edge}{vector}}$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ TSPAlgorithms\+::get\+Odd\+Degrees (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_graph}{Graph}}}]{mst\+Graph }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Gets the vertices with odd degrees in the MST. 


\begin{DoxyParams}{Parameters}
{\em mst\+Graph} & The MST graph. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The vertices with odd degrees.
\end{DoxyReturn}
Complexity\+: O(\+V) where V is the number of vertices. \Hypertarget{class_t_s_p_algorithms_afba4fbbec08698e6172dbcd19a62a215}\label{class_t_s_p_algorithms_afba4fbbec08698e6172dbcd19a62a215} 
\index{TSPAlgorithms@{TSPAlgorithms}!isGraphFullyConnected@{isGraphFullyConnected}}
\index{isGraphFullyConnected@{isGraphFullyConnected}!TSPAlgorithms@{TSPAlgorithms}}
\doxysubsubsection{\texorpdfstring{isGraphFullyConnected()}{isGraphFullyConnected()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_edge}{bool}} TSPAlgorithms\+::is\+Graph\+Fully\+Connected (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Checks if the graph is fully connected. 

\begin{DoxyReturn}{Returns}
True if the graph is fully connected, false otherwise.
\end{DoxyReturn}
Complexity\+: O(1) \Hypertarget{class_t_s_p_algorithms_a9c4c801c892093c4aaf15a22bf3c685a}\label{class_t_s_p_algorithms_a9c4c801c892093c4aaf15a22bf3c685a} 
\index{TSPAlgorithms@{TSPAlgorithms}!loadGraph@{loadGraph}}
\index{loadGraph@{loadGraph}!TSPAlgorithms@{TSPAlgorithms}}
\doxysubsubsection{\texorpdfstring{loadGraph()}{loadGraph()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_edge}{void}} TSPAlgorithms\+::load\+Graph (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Loads the graph by first loading the vertices and then the edges. 

Complexity\+: O(V + E) where V is the number of vertices and E is the number of edges. \Hypertarget{class_t_s_p_algorithms_af964e3fa6df8ef1477fa472b2daf608d}\label{class_t_s_p_algorithms_af964e3fa6df8ef1477fa472b2daf608d} 
\index{TSPAlgorithms@{TSPAlgorithms}!loadGraphEdges@{loadGraphEdges}}
\index{loadGraphEdges@{loadGraphEdges}!TSPAlgorithms@{TSPAlgorithms}}
\doxysubsubsection{\texorpdfstring{loadGraphEdges()}{loadGraphEdges()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_edge}{void}} TSPAlgorithms\+::load\+Graph\+Edges (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_edge}{unsigned}} \mbox{\hyperlink{class_edge}{int}} \&}]{number\+Of\+Graph\+Edges }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Loads the edges of the graph and calculates the number of edges. 


\begin{DoxyParams}{Parameters}
{\em number\+Of\+Graph\+Edges} & The reference to store the number of graph edges.\\
\hline
\end{DoxyParams}
Complexity\+: O(\+E) where E is the number of edges. \Hypertarget{class_t_s_p_algorithms_a3957e450d4599f8ee3ff28105b6aed02}\label{class_t_s_p_algorithms_a3957e450d4599f8ee3ff28105b6aed02} 
\index{TSPAlgorithms@{TSPAlgorithms}!loadGraphVertexes@{loadGraphVertexes}}
\index{loadGraphVertexes@{loadGraphVertexes}!TSPAlgorithms@{TSPAlgorithms}}
\doxysubsubsection{\texorpdfstring{loadGraphVertexes()}{loadGraphVertexes()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_edge}{void}} TSPAlgorithms\+::load\+Graph\+Vertexes (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Loads the vertices of the graph from different data sources based on the graph name. 

Complexity\+: O(\+V) where V is the number of vertices. \Hypertarget{class_t_s_p_algorithms_a692f2d66d8b3f323a4047c610a4a0ebf}\label{class_t_s_p_algorithms_a692f2d66d8b3f323a4047c610a4a0ebf} 
\index{TSPAlgorithms@{TSPAlgorithms}!MSTPreOrderVisitDFS@{MSTPreOrderVisitDFS}}
\index{MSTPreOrderVisitDFS@{MSTPreOrderVisitDFS}!TSPAlgorithms@{TSPAlgorithms}}
\doxysubsubsection{\texorpdfstring{MSTPreOrderVisitDFS()}{MSTPreOrderVisitDFS()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_edge}{void}} TSPAlgorithms\+::\+MSTPre\+Order\+Visit\+DFS (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}}]{root,  }\item[{\mbox{\hyperlink{class_edge}{vector}}$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \&}]{min\+Distance\+Path }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Performs a pre-\/order DFS visit of the MST. 


\begin{DoxyParams}{Parameters}
{\em root} & The root vertex. \\
\hline
{\em min\+Distance\+Path} & The path with the minimum distance.\\
\hline
\end{DoxyParams}
Complexity\+: O(V + E) where V is the number of vertices and E is the number of edges. \Hypertarget{class_t_s_p_algorithms_a1828911a5c896eed0f47ffc54a5f907d}\label{class_t_s_p_algorithms_a1828911a5c896eed0f47ffc54a5f907d} 
\index{TSPAlgorithms@{TSPAlgorithms}!primAlgorithm@{primAlgorithm}}
\index{primAlgorithm@{primAlgorithm}!TSPAlgorithms@{TSPAlgorithms}}
\doxysubsubsection{\texorpdfstring{primAlgorithm()}{primAlgorithm()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_edge}{void}} TSPAlgorithms\+::prim\+Algorithm (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}}]{root }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Performs Prim\textquotesingle{}s algorithm to create an MST starting from the root vertex. 


\begin{DoxyParams}{Parameters}
{\em root} & The root vertex.\\
\hline
\end{DoxyParams}
Complexity\+: O(\+E \texorpdfstring{$\ast$}{*} log\+V) where V is the number of vertices and E is the number of edges. \Hypertarget{class_t_s_p_algorithms_ae42132ecda567c2332390f7f9403cd95}\label{class_t_s_p_algorithms_ae42132ecda567c2332390f7f9403cd95} 
\index{TSPAlgorithms@{TSPAlgorithms}!primAlgorithmChristofides@{primAlgorithmChristofides}}
\index{primAlgorithmChristofides@{primAlgorithmChristofides}!TSPAlgorithms@{TSPAlgorithms}}
\doxysubsubsection{\texorpdfstring{primAlgorithmChristofides()}{primAlgorithmChristofides()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_edge}{void}} TSPAlgorithms\+::prim\+Algorithm\+Christofides (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_graph}{Graph}} \&}]{mst\+Graph,  }\item[{\mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}}]{vertex }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Performs Prim\textquotesingle{}s algorithm for Christofides to create an MST. 


\begin{DoxyParams}{Parameters}
{\em mst\+Graph} & The MST graph to be created. \\
\hline
{\em root} & The root vertex.\\
\hline
\end{DoxyParams}
Complexity\+: O(\+E \texorpdfstring{$\ast$}{*} log\+V) where V is the number of vertices and E is the number of edges. \Hypertarget{class_t_s_p_algorithms_aa4f1c8253c475ccb98f69d4a342c52c6}\label{class_t_s_p_algorithms_aa4f1c8253c475ccb98f69d4a342c52c6} 
\index{TSPAlgorithms@{TSPAlgorithms}!setAllVertexesAsUnvisited@{setAllVertexesAsUnvisited}}
\index{setAllVertexesAsUnvisited@{setAllVertexesAsUnvisited}!TSPAlgorithms@{TSPAlgorithms}}
\doxysubsubsection{\texorpdfstring{setAllVertexesAsUnvisited()}{setAllVertexesAsUnvisited()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_edge}{void}} TSPAlgorithms\+::set\+All\+Vertexes\+As\+Unvisited (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Sets all vertices in the graph as unvisited. 

Complexity\+: O(\+V) where V is the number of vertices. \Hypertarget{class_t_s_p_algorithms_ad109e1d5a64bea6518987510325e5caa}\label{class_t_s_p_algorithms_ad109e1d5a64bea6518987510325e5caa} 
\index{TSPAlgorithms@{TSPAlgorithms}!setAllVertexPathsNull@{setAllVertexPathsNull}}
\index{setAllVertexPathsNull@{setAllVertexPathsNull}!TSPAlgorithms@{TSPAlgorithms}}
\doxysubsubsection{\texorpdfstring{setAllVertexPathsNull()}{setAllVertexPathsNull()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_edge}{void}} TSPAlgorithms\+::set\+All\+Vertex\+Paths\+Null (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Sets the path of all vertices to null. 

Complexity\+: O(\+V) where V is the number of vertices. \Hypertarget{class_t_s_p_algorithms_ae6a82fda7b3eac284ede9c61c65766e0}\label{class_t_s_p_algorithms_ae6a82fda7b3eac284ede9c61c65766e0} 
\index{TSPAlgorithms@{TSPAlgorithms}!setGraphName@{setGraphName}}
\index{setGraphName@{setGraphName}!TSPAlgorithms@{TSPAlgorithms}}
\doxysubsubsection{\texorpdfstring{setGraphName()}{setGraphName()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_edge}{void}} TSPAlgorithms\+::set\+Graph\+Name (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_edge}{const}} \mbox{\hyperlink{class_edge}{string}} \&}]{graph\+Name }\end{DoxyParamCaption})}



Sets the name of the graph. 


\begin{DoxyParams}{Parameters}
{\em graph\+Name} & The new name of the graph.\\
\hline
\end{DoxyParams}
Complexity\+: O(1) 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
TSPAlgorithms.\+h\item 
TSPAlgorithms.\+cpp\end{DoxyCompactItemize}
